;; ????: should auction been destroyed in case on canellation (if not - how to re-deploy/re-open it again?)
;; ????: ANY mesage will be sufficient? NO - finish by OP commend also needed
;;       If auction is finished by time - than this process should be able to be initialized via some control message to auction smart contract
;; TODO: All methods of sales smart contract should require some extra coins for gas & message fees and should return not used coins to the initiator.
;; TODO: auction anti-sniping prolongation

;; ????: add seed to auction
;; ????: min_tons_for_storage()

;; what if one will increase bid by 1 nanoton each snipe time? Should we also have min_bid_step?


;; NFT auction smart contract


int min_gas_amount() asm "50000000 PUSHINT"; ;; 0.05 TON
;; int min_tons_for_storage() asm "50000000 PUSHINT"; ;; 0.05 TON


(slice, slice, slice, cell, cell, cell) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_msg_addr(), ;; marketplace_address 
    ds~load_msg_addr(), ;; nft_address
    ds~load_msg_addr(), ;; nft_owner_address
    ds~load_ref(),      ;; marketplace_fee_params
    ds~load_ref(),      ;; royalty_params
    ds~load_ref()       ;; auction_params
  );
}


(int, int, int, int, int, slice, int, int, int) load_auction_data(cell auction_params) inline {
  var ds = auction_params.begin_parse();
  return (
    ds~load_uint(32),   ;; auction_finish_time
    ds~load_int(32),    ;; sniper_before_time
    ds~load_int(32),    ;; sniper_after_prolong
    ds~load_coins(),    ;; min_bid_value
    ds~load_coins(),    ;; max_bid_value
    ds~load_msg_addr(), ;; curr_winner_addr
    ds~load_coins(),    ;; curr_winner_bid
    ds~load_int(1),     ;; is_finished
    ds~load_int(1)      ;; is_cancelled
  );
}


(slice, int, int) load_fees(cell fee_params) inline {
  var ds = fee_params.begin_parse();
  return (
    ds~load_msg_addr(), ;; fee_address 
    ds~load_uint(16),   ;; fee_numer
    ds~load_uint(16)    ;; fee_denom
  );
}


() save_data(slice marketplace_address, slice nft_address, slice nft_owner_address,
             cell marketplace_fee_params, cell royalty_params,
             int auction_finish_time,
             int sniper_before_time,
             int sniper_after_prolong,
             int min_bid_value,
             int max_bid_value,
             slice curr_winner_addr,
             int curr_winner_bid,
             int finished?,
             int cancelled?) impure inline {
  set_data(begin_cell()
            .store_slice(marketplace_address)
            .store_slice(nft_address)
            .store_slice(nft_owner_address)
            .store_ref(marketplace_fee_params)
            .store_ref(royalty_params)
            .store_ref(begin_cell()
                        .store_uint(auction_finish_time, 32)
                        .store_coins(min_bid_value)
                        .store_coins(max_bid_value)
                        .store_slice(curr_winner_addr)
                        .store_coins(curr_winner_bid)
                        .store_int(finished?, 1)
                        .store_int(cancelled?, 1)
                      .end_cell())
          .end_cell());
}


() return_bid_to_sender(slice sender_address, int msg_value) impure inline {
  throw_unless(450, msg_value >= min_gas_amount());

  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce
    .store_slice(sender_address)
    .store_coins(msg_value)      ;; ??????????????  msg_value - min_gas_amount()
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
  .end_cell();

  send_raw_message(msg, 64); ;; carry all inbound amount minus fees

  return ();
} 


() finish_auction(int my_balance, int msg_value, int query_id,
                  slice marketplace_address, slice nft_address, slice nft_owner_address,
                  cell marketplace_fee_params, cell royalty_params,
                  int auction_finish_time, int sniper_before_time, int sniper_after_prolong,
                  int min_bid_value, int max_bid_value,
                  slice winner_address, int winner_bid, 
                  int finished?) impure {
  throw_unless(447, msg_value >= min_gas_amount());
  throw_if(600, finished?);

  ;; if there is a winner: pay fees
  if (~ null?(winner_address)) {
    var (royalty_addr, royalty_numer, royalty_denom) = load_fees(royalty_params);
    var (marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom) = load_fees(marketplace_fee_params);

    ;; royalty fees
    int royalty_amount = (winner_bid / royalty_denom) * royalty_numer;
    var royalty_msg = begin_cell()
                        .store_uint(0x10, 6) ;; nobounce
                        .store_slice(royalty_addr)
                        .store_coins(royalty_amount)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                      .end_cell();

    send_raw_message(royalty_msg, 1);

    ;; marketplace fees
    int marketplace_fee = (winner_bid / marketplace_fee_denom) * marketplace_fee_numer;
    var marketplace_msg = begin_cell()
                            .store_uint(0x10, 6) ;; nobounce
                            .store_slice(marketplace_fee_addr)
                            .store_coins(marketplace_fee)
                            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                          .end_cell();

    send_raw_message(marketplace_msg, 1);

    ;; send winner's bid to NFT owner
    var owner_msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce
            .store_slice(nft_owner_address)
            .store_coins(my_balance - marketplace_fee - royalty_amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();

    send_raw_message(owner_msg, 1);
  }

  slice new_nft_owner = null?(winner_address) ? nft_owner_address : winner_address;

  ;; transfer NFT to new (or the same in case of no bids) owner
  var msg = begin_cell()
              .store_uint(0x18, 6) 
              .store_slice(nft_address)
              .store_coins(0)
              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .store_uint(op::transfer(), 32)
              .store_uint(query_id, 64)
              .store_slice(new_nft_owner) ;; new_owner_address
              .store_slice(new_nft_owner) ;; response_address
              .store_int(0, 1)  ;; empty custom_payload
              .store_coins(0)   ;; forward amount to new_owner_address
              .store_int(0, 1)  ;; empty forward_payload
            .end_cell();

  send_raw_message(msg, 1);

  save_data(marketplace_address, nft_address, new_nft_owner,
            marketplace_fee_params, royalty_params,
            auction_finish_time,
            sniper_before_time,
            sniper_after_prolong,
            min_bid_value,
            max_bid_value,
            winner_address,
            winner_bid,
            -1, 0);

  return ();
}


() bid(int my_balance, int msg_value, int query_id,
       slice marketplace_address, slice nft_address, slice nft_owner_address, 
       cell marketplace_fee_params, cell royalty_params,
       slice sender_address,
       int auction_finish_time, int sniper_before_time, int sniper_after_prolong,
       int min_bid_value, int max_bid_value,
       slice curr_winner_addr, int curr_winner_bid,
       int finished?) impure {
  int bid_value = msg_value - min_gas_amount();

  throw_unless(450, bid_value >= min_bid_value);

  int curr_bid = max(min_bid_value, curr_winner_bid);

  ;; return all bid amount to sender if one of the following holds:
  ;;    1. bid is insufficient
  ;;    2. bid is already done
  if ((bid_value < curr_bid) |
      ((bid_value == curr_bid) & (~ null?(curr_winner_addr)))) { 
    return_bid_to_sender(sender_address, bid_value);

    return ();
  }

  ;; max bid occured: finish auction immediately
  if ((~ null?(max_bid_value)) & (bid_value >= max_bid_value)) {
    finish_auction(my_balance, msg_value, query_id,
                   marketplace_address, nft_address, nft_owner_address,
                   marketplace_fee_params, royalty_params,
                   auction_finish_time, sniper_before_time, sniper_after_prolong,
                   min_bid_value, max_bid_value,
                   sender_address, bid_value, 
                   finished?);

    return();
  }

  ;; (curr_winner_bid < bid_value < max_bid_value): do next bid
  ;; return previous bid to bidder
  var msg = begin_cell()
              .store_uint(0x10, 6) ;; nobounce
              .store_slice(curr_winner_addr)
              .store_coins(curr_winner_bid)
              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();

  send_raw_message(msg, 1);

  ;; assign new current winner
  save_data(marketplace_address, nft_address, nft_owner_address,
            marketplace_fee_params, royalty_params,
            auction_finish_time, sniper_before_time, sniper_after_prolong, 
            min_bid_value, max_bid_value,
            sender_address, bid_value,
            0, 0);

  return ();
}


() cancel_auction(int my_balance, int msg_value, int query_id,
                  slice marketplace_address, slice nft_address, slice nft_owner_address,
                  cell marketplace_fee_params, cell royalty_params,
                  slice sender_address, 
                  int auction_finish_time, int sniper_before_time, int sniper_after_prolong,
                  int min_bid_value, int max_bid_value,
                  slice curr_winner_addr, int curr_winner_bid,
                  int finished?) impure {
  throw_unless(457, msg_value >= min_gas_amount());
  throw_unless(458, equal_slices(sender_address, nft_owner_address) | 
                    equal_slices(sender_address, marketplace_address)); ;; ????????????????????????????
  throw_if(600, finished?);

  ;; return last bid (if any)
  if (~ null?(curr_winner_addr)) {
    return_bid_to_sender(curr_winner_addr, curr_winner_bid);
  }

  ;; return NFT back to owner
  var msg = begin_cell()
              .store_uint(0x10, 6) ;; nobounce
              .store_slice(nft_address)
              .store_coins(0)
              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .store_uint(op::transfer(), 32)
              .store_uint(query_id, 64) 
              .store_slice(nft_owner_address) ;; new_owner_address
              .store_slice(nft_owner_address) ;; response_address;
              .store_int(0, 1)  ;; empty custom_payload
              .store_coins(0)   ;; forward amount to new_owner_address
              .store_int(0, 1)  ;; empty forward_payload
            .end_cell();

  send_raw_message(msg, 1);

  save_data(marketplace_address, nft_address, nft_owner_address,
           marketplace_fee_params, royalty_params,
           auction_finish_time, sniper_before_time, sniper_after_prolong, 
           min_bid_value, max_bid_value,
           curr_winner_addr, curr_winner_bid,
           -1, -1);

  return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {  ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    var (marketplace_address, nft_address, nft_owner_address, 
         marketplace_fee_params, royalty_params, auction_params) = load_data();
    var (auction_finish_time, sniper_before_time, sniper_after_prolong,
         min_bid_value, max_bid_value,
         curr_winner_addr, curr_winner_bid,
         finished?, cancelled?) = load_auction_data(auction_params);

    var is_initialized = nft_owner_address.slice_bits() > 2; ;; not initialized if null address

    if (~ is_initialized) {
      ;; deploy auction from marketplace: set state_init, accept coins
      if (equal_slices(sender_address, marketplace_address)) {
         return ();
      }

      ;; first call must be from NFT item
      throw_unless(500, equal_slices(sender_address, nft_address));

      int op = in_msg_body~load_uint(32);
      throw_unless(501, op == op::ownership_assigned());

      int query_id = in_msg_body~load_uint(64);
      slice prev_owner_address = in_msg_body~load_msg_addr();

      save_data(marketplace_address, nft_address, prev_owner_address,
                marketplace_fee_params, royalty_params,
                auction_finish_time, sniper_before_time, sniper_after_prolong,
                min_bid_value, max_bid_value,
                null(), 0,
                0, 0);

      return ();
    }

    ;; check time is up
    if (~ null?(auction_finish_time) & (now() > auction_finish_time)) {

      ;; return bid back to sender
      return_bid_to_sender(sender_address, msg_value);

      if (~ finished?) {
        ;; auction not finished yet: finish him
        finish_auction(my_balance, msg_value, 0,
                       marketplace_address, nft_address, nft_owner_address,
                       marketplace_fee_params, royalty_params,
                       auction_finish_time, sniper_before_time, sniper_after_prolong,
                       min_bid_value, max_bid_value,
                       curr_winner_addr, curr_winner_bid, 
                       finished?);
      }

      return ();
    }

    ;; simple transfer - make a bid
    if (in_msg_body.slice_empty?()) {
      bid(my_balance, msg_value, 0, 
          marketplace_address, nft_address, nft_owner_address,
          marketplace_fee_params, royalty_params,
          sender_address,
          auction_finish_time, sniper_before_time, sniper_after_prolong,
          min_bid_value, max_bid_value, 
          curr_winner_addr, curr_winner_bid,
          finished?);

      return ();
    }

    int op = in_msg_body~load_uint(32);
    if (op == 1) { ;; just accept coins
      return ();
    }
    int query_id = in_msg_body~load_uint(64);

    ;; make a bid
    if (op == op::auction_bid()) { 
      bid(my_balance, msg_value, query_id, 
          marketplace_address, nft_address, nft_owner_address,
          marketplace_fee_params, royalty_params,
          sender_address,
          auction_finish_time, sniper_before_time, sniper_after_prolong,
          min_bid_value, max_bid_value,
          curr_winner_addr, curr_winner_bid,
          finished?);

      return ();
    }

    ;; cancel auction
    if (op == op::auction_cancel()) { 
      cancel_auction(my_balance, msg_value, query_id, 
                     marketplace_address, nft_address, nft_owner_address,
                     marketplace_fee_params, royalty_params,
                     sender_address, 
                     auction_finish_time, sniper_before_time, sniper_after_prolong,
                     min_bid_value, max_bid_value,
                     curr_winner_addr, curr_winner_bid,
                     finished?);

      return ();
    }

    ;; manually finish auction
    if (op == op::auction_finish()) { 
      finish_auction(my_balance, msg_value, query_id,
                     marketplace_address, nft_address, nft_owner_address, 
                     marketplace_fee_params, royalty_params,
                     auction_finish_time, sniper_before_time, sniper_after_prolong,
                     min_bid_value, max_bid_value,
                     curr_winner_addr, curr_winner_bid,
                     finished?);

      return ();
    }

    throw(0xffff);
}


() recv_external(slice in_msg) impure {
}


(slice, slice, slice, int, int, int, slice, int, int, slice, int, int, slice, int, int, int) get_auction_data() method_id {
  var (marketplace_address, nft_address, nft_owner_address,
       marketplace_fee_params, royalty_params, auction_params) = load_data();
  var (marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom) = load_fees(marketplace_fee_params);
  var (royalty_addr, royalty_fee_numer, royalty_denom) = load_fees(royalty_params);
  var (auction_finish_time, sniper_before_time, sniper_after_prolong,
       min_bid_value, max_bid_value,
       curr_winner_addr, curr_winner_bid,
       finished?, cancelled?) = load_auction_data(auction_params);


  return (
    marketplace_address, nft_address, nft_owner_address, 
    auction_finish_time, 
    min_bid_value,
    max_bid_value,
    marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom,
    royalty_addr, royalty_fee_numer, royalty_denom,
    curr_winner_addr,
    curr_winner_bid,
    finished?,
    cancelled?
  );
}
