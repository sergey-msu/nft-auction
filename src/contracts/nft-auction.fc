;; NFT auction smart contract


int min_gas_amount() asm "100000000 PUSHINT"; ;; 0.1 TON


(slice, slice, slice, int, int, int, cell, cell, slice, int, int, int) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_msg_addr(), ;; marketplace_address 
    ds~load_msg_addr(), ;; nft_address
    ds~load_msg_addr(), ;; nft_owner_address
    ds~load_uint(32),   ;; auction_finish_time
    ds~load_coins(),    ;; min_bid_value
    ds~load_coins(),    ;; max_bid_value
    ds~load_ref(),      ;; marketplace_fee_params 
    ds~load_ref(),      ;; royalty_params
    ds~load_msg_addr(), ;; curr_winner_addr
    ds~load_coins(),    ;; curr_winner_bid
    ds~load_int(1),     ;; is_finished
    ds~load_int(1)      ;; is_cancelled
  );
}


(slice, int, int) load_fees(cell fee_params) inline {
  var ds = fee_params.begin_parse();
  return (
    ds~load_msg_addr(), ;; fee_address 
    ds~load_uint(16),   ;; fee_numer
    ds~load_uint(16)    ;; fee_denom
  );
}


() save_data(slice marketplace_address, 
             slice nft_address, 
             slice nft_owner_address, 
             int auction_finish_time, 
             int min_bid_value,
             int max_bid_value,
             cell marketplace_fee_params,
             cell royalty_params,
             slice curr_winner_addr,
             int curr_winner_bid,
             int finished?,
             int cancelled?) impure inline {
  set_data(begin_cell()
            .store_slice(marketplace_address)
            .store_slice(nft_address)
            .store_slice(nft_owner_address)
            .store_uint(auction_finish_time, 32)
            .store_coins(min_bid_value)
            .store_coins(max_bid_value)
            .store_ref(marketplace_fee_params)
            .store_ref(royalty_params)
            .store_slice(curr_winner_addr)
            .store_coins(curr_winner_bid)
            .store_int(finished?, 1)
            .store_int(cancelled?, 1)
          .end_cell());
}


(slice, int) finish_auction(int my_balance,
                            int msg_value,
                            slice nft_address,
                            slice nft_owner_address,
                            slice winner_address, 
                            int winner_bid, 
                            cell marketplace_fee_params, 
                            cell royalty_params,
                            int query_id,
                            int finished?) impure {
  throw_unless(457, winner_bid >= min_gas_amount());
  throw_if(600, finished?);

  ;; if there is a winner: pay fees
  if (~ null?(winner_address)) {
    var (royalty_addr, royalty_numer, royalty_denom) = load_fees(royalty_params);
    var (marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom) = load_fees(marketplace_fee_params);

    ;; royalty fees
    int royalty_amount = (winner_bid / royalty_denom) * royalty_numer;
    var royalty_msg = begin_cell()
                        .store_uint(0x10, 6) ;; nobounce
                        .store_slice(royalty_addr)
                        .store_coins(royalty_amount)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                      .end_cell();

    send_raw_message(royalty_msg, 1);

    ;; marketplace fees
    int marketplace_fee = (winner_bid / marketplace_fee_denom) * marketplace_fee_numer;
    var marketplace_msg = begin_cell()
                            .store_uint(0x10, 6) ;; nobounce
                            .store_slice(marketplace_fee_addr)
                            .store_coins(marketplace_fee)
                            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                          .end_cell();

    send_raw_message(marketplace_msg, 1);

    ;; send winner's bid to NFT owner
    var owner_msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce
            .store_slice(nft_owner_address)
            .store_coins(winner_bid - marketplace_fee - royalty_amount + (my_balance - msg_value))
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();

    send_raw_message(owner_msg, 1);
  }

  slice new_nft_owner = null?(winner_address) ? nft_owner_address : winner_address;

  ;; transfer NFT to new (or the same in case of no bids) owner
  var msg = begin_cell()
              .store_uint(0x18, 6) 
              .store_slice(nft_address)
              .store_coins(0)
              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .store_uint(op::transfer(), 32)
              .store_uint(query_id, 64)
              .store_slice(new_nft_owner) ;; new_owner_address
              .store_slice(new_nft_owner) ;; response_address
              .store_int(0, 1)  ;; empty custom_payload
              .store_coins(0)   ;; forward amount to new_owner_address
              .store_int(0, 1)  ;; empty forward_payload
            .end_cell();

  send_raw_message(msg, 1);

  return (new_nft_owner, winner_bid);
}


(slice, int, int) bid(int my_balance,
                      int msg_value, 
                      slice sender_address,
                      slice nft_address,
                      slice nft_owner_address,
                      int min_bid_value,
                      int max_bid_value,
                      int auction_finish_time, 
                      slice curr_winner_addr, 
                      int curr_winner_bid,
                      cell marketplace_fee_params, 
                      cell royalty_params,
                      int query_id,
                      int finished?) impure {
  throw_unless(450, msg_value >= min_bid_value + min_gas_amount());

  int curr_bid = max(min_bid_value, curr_winner_bid);

  ;; return all bid amount to sender if one of the following holds:
  ;;    1. auction already finished
  ;;    2. time is up
  ;;    3. bid is insufficient
  ;;    4. bid is already done
  if (finished? |
      (now() >= auction_finish_time) | 
      (msg_value < curr_bid) |
      ((msg_value == curr_bid) & (~ null?(curr_winner_addr)))) { 
    var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(sender_address)
                .store_coins(msg_value)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .end_cell();

    send_raw_message(msg, 64); ;; carry all inbound amount minus fees
  }
  ;; max bid occured: finish auction immediately
  elseif (msg_value >= max_bid_value) {
    var (new_winner_addr, new_winner_bid) = 
      finish_auction(my_balance,
                     msg_value,
                     nft_address,
                     nft_owner_address,
                     sender_address, 
                     msg_value, 
                     marketplace_fee_params, 
                     royalty_params,
                     query_id,
                     finished?);
    curr_winner_addr = new_winner_addr;
    curr_winner_bid = new_winner_bid;
    finished? = -1;
  }

  ;; (curr_winner_bid < msg_value < max_bid_value): do next bid
  else {
    ;; return previous bid to bidder
    var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(curr_winner_addr)
                .store_coins(curr_winner_bid)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .end_cell();

    send_raw_message(msg, 1);

    ;; assign new current winner
    curr_winner_addr = sender_address;
    curr_winner_bid = msg_value;
    finished? = 0;
  }

  return (curr_winner_addr, curr_winner_bid, finished?);
}


() cancel_auction(int msg_value, 
                  slice sender_address, 
                  slice nft_address, 
                  slice nft_owner_address, 
                  slice marketplace_address, 
                  slice curr_winner_addr, 
                  int curr_winner_bid,
                  int min_bid_value,
                  int query_id,
                  int finished?) impure {
  throw_unless(457, msg_value >= min_gas_amount());
  throw_unless(458, equal_slices(sender_address, nft_owner_address) | 
                    equal_slices(sender_address, marketplace_address)); ;; ????????????????????????????
  throw_if(600, finished?);

  ;; return last bid (if any)
  if (~ null?(curr_winner_addr)) {
    var msg = begin_cell()
                .store_uint(0x10, 6) ;; nobounce
                .store_slice(curr_winner_addr)
                .store_coins(curr_winner_bid)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .end_cell();

    send_raw_message(msg, 1);
  }

  ;; return NFT back to owner
  var msg = begin_cell()
              .store_uint(0x10, 6) ;; nobounce
              .store_slice(nft_address)
              .store_coins(0)
              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
              .store_uint(op::transfer(), 32)
              .store_uint(query_id, 64) 
              .store_slice(nft_owner_address) ;; new_owner_address
              .store_slice(nft_owner_address) ;; response_address;
              .store_int(0, 1)  ;; empty custom_payload
              .store_coins(0)   ;; forward amount to new_owner_address
              .store_int(0, 1)  ;; empty forward_payload
            .end_cell();

  send_raw_message(msg, 1);

  return ();
}


(slice, int, int) check_auction(int my_balance,
                                int msg_value,
                                slice nft_address, 
                                slice nft_owner_address,
                                int auction_finish_time, 
                                slice curr_winner_addr, 
                                int curr_winner_bid,
                                cell marketplace_fee_params,
                                cell royalty_params,
                                int query_id,
                                int finished?) impure {
  ;; time is up check
  if (now() > auction_finish_time) {
    var (new_winner_addr, new_winner_bid) = 
      finish_auction(my_balance,
                     msg_value,
                     nft_address,
                     nft_owner_address,
                     curr_winner_addr, 
                     curr_winner_bid, 
                     marketplace_fee_params, 
                     royalty_params,
                     query_id,
                     finished?);

    return (new_winner_addr, new_winner_bid, -1);
  }

  return (curr_winner_addr, curr_winner_bid, 0);
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {  ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    var (marketplace_address, 
         nft_address, 
         nft_owner_address, 
         auction_finish_time, 
         min_bid_value,
         max_bid_value,
         marketplace_fee_params,
         royalty_params,
         curr_winner_addr,
         curr_winner_bid,
         finished?,
         cancelled?) = load_data();

    var is_initialized = nft_owner_address.slice_bits() > 2; ;; not initialized if null address

    if (~ is_initialized) {
      ;; deploy auction from marketplace: set state_init, accept coins
      if (equal_slices(sender_address, marketplace_address)) {
         return ();
      }

      ;; first call must be from NFT item
      throw_unless(500, equal_slices(sender_address, nft_address));

      int op = in_msg_body~load_uint(32);
      throw_unless(501, op == op::ownership_assigned());

      int query_id = in_msg_body~load_uint(64);
      slice prev_owner_address = in_msg_body~load_msg_addr();

      save_data(marketplace_address, 
                nft_address, 
                prev_owner_address,
                auction_finish_time, 
                min_bid_value,
                max_bid_value,
                marketplace_fee_params,
                royalty_params,
                null(), 0, 0, 0);

      return ();
    }

    ;; check auction is already finished
    if (~ finished?) {
      var (new_winner_addr, new_winner_bid, new_finished?) = 
        check_auction(my_balance,
                      msg_value,
                      nft_address, 
                      nft_owner_address,
                      auction_finish_time,
                      curr_winner_addr, 
                      curr_winner_bid,
                      marketplace_fee_params,
                      royalty_params,
                      0,
                      finished?);

        curr_winner_addr = new_winner_addr;
        curr_winner_bid = new_winner_bid;
        finished? = new_finished?;
    }

    ;; simple transfer - make a bid
    if (in_msg_body.slice_empty?()) {
      var (new_winner_addr, new_winner_bid, finished?) = 
        bid(my_balance,
            msg_value, 
            sender_address,
            nft_address,
            nft_owner_address,
            min_bid_value,
            max_bid_value,
            auction_finish_time, 
            curr_winner_addr, 
            curr_winner_bid,
            marketplace_fee_params, 
            royalty_params,
            0,
            finished?);

      save_data(marketplace_address, 
                nft_address, 
                nft_owner_address,
                auction_finish_time, 
                min_bid_value,
                max_bid_value,
                marketplace_fee_params,
                royalty_params,
                new_winner_addr,
                new_winner_bid,
                finished?,
                0);

      return ();
    }

    int op = in_msg_body~load_uint(32);
    if (op == 1) { ;; just accept coins
      return ();
    }
    int query_id = in_msg_body~load_uint(64);

    ;; make a bid
    if (op == op::auction_bid()) { 
      var (new_winner_addr, new_winner_bid, finished?) = 
        bid(my_balance,
            msg_value, 
            sender_address,
            nft_address,
            nft_owner_address,
            min_bid_value,
            max_bid_value,
            auction_finish_time, 
            curr_winner_addr, 
            curr_winner_bid,
            marketplace_fee_params, 
            royalty_params,
            query_id,
            finished?);

      save_data(marketplace_address, 
                nft_address, 
                nft_owner_address,
                auction_finish_time, 
                min_bid_value,
                max_bid_value,
                marketplace_fee_params,
                royalty_params,
                new_winner_addr,
                new_winner_bid,
                finished?,
                0);

      return ();
    }

    ;; cancel auction
    if (op == op::auction_cancel()) { 
      cancel_auction(msg_value, 
                     sender_address, 
                     nft_address, 
                     nft_owner_address, 
                     marketplace_address, 
                     curr_winner_addr, 
                     curr_winner_bid,
                     min_bid_value,
                     query_id,
                     finished?);

      save_data(marketplace_address, 
                nft_address, 
                nft_owner_address,
                auction_finish_time, 
                min_bid_value,
                max_bid_value,
                marketplace_fee_params,
                royalty_params,
                curr_winner_addr,
                curr_winner_bid,
                -1,
                -1);

      return ();
    }

    throw(0xffff);
}


() recv_external(slice in_msg) impure {
}


(slice, slice, slice, int, int, int, slice, int, int, slice, int, int, slice, int, int, int) get_auction_data() method_id {
  var (marketplace_address, 
       nft_address, 
       nft_owner_address, 
       auction_finish_time, 
       min_bid_value,
       max_bid_value,
       marketplace_fee_params,
       royalty_params,
       curr_winner_addr,
       curr_winner_bid,
       finished?,
       cancelled?) = load_data();
  var (marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom) = load_fees(marketplace_fee_params);
  var (royalty_addr, royalty_fee_numer, royalty_denom) = load_fees(royalty_params);

  return (
    marketplace_address, 
    nft_address, 
    nft_owner_address, 
    auction_finish_time, 
    min_bid_value,
    max_bid_value,
    marketplace_fee_addr, marketplace_fee_numer, marketplace_fee_denom,
    royalty_addr, royalty_fee_numer, royalty_denom,
    curr_winner_addr,
    curr_winner_bid,
    finished?,
    cancelled?
  );
}
