// Test #10. Add one (first) approved signature.


"test-00-header.fif" include


"EQAWYHnDf8qmG9mC1CGD1Svf9_9OjWpDgL9EU2fgsTrfH5jG" dup =: owner_address $>smca 0= abort"bad address"
=: owner_flags
=: owner_addr
=: owner_wc

"EQDK-Qt00761ArsHAK5MevbckLBxyHMmjpUEJ4cHWMKOYsZB" dup =: provider_address $>smca 0= abort"bad address"
=: provider_flags
=: provider_addr
=: provider_wc

"EQCv4tjf-7E9V42WMlRYVPsHtjfiMv3l3-jk4CyE8dz5ReFi" dup =: signee_address $>smca 0= abort"bad address"
=: signee_flags
=: signee_addr
=: signee_wc

// from *.fc:  var (x, y) = parse_std_addr(sign_request_address);
0 14170262488431536613590598689173796411624622065219871872304091021486461376822 0 smca>$ dup =: request_address $>smca 0= abort"bad address"
=: request_flags
=: request_addr
=: request_wc


<b
   b{100} s, owner_wc 8 i, owner_addr 256 u, // owner address
   7 64 u,        // next_item_index
   <b b> ref,     // content
   <b b> ref,     // nft_item_code
   <b b> ref,     // royalty_params
   <b
      10 8 u,           // sign_max_number
      0 8 u,            // sign_number
       500000000 Gram,  // sign_deploy_fee
      1500000000 Gram,  // sign_commit_fee
      9000000000 Gram,  // min_stake
      b{100} s, provider_wc 8 i, provider_addr 256 u, // sign_provider_address
      sign_request_code s>c ref, // sign_request_code
      dictnew dict,     // signatures
   b> ref,
b> =: init_state


// ------------------------ Case 1: Correct request address, sign added ----------------------

<b
   // flags: int_msg_info, ihr_disabled, bounce, bounced
   b{0100} s,

   // sender address
   b{100} s, request_wc 8 i, request_addr 256 u,
b> =: in_msg_full

<b
   0x14D 32 u,   // op code
   0 64 u,       // query_id
   b{100} s, signee_wc 8 i, signee_addr 256 u, // wanted signee address
b> <s =: in_msg_body


in_msg_full
in_msg_body
recv_internal
code
init_state
c7
runvmctx

=: state
=: exit_code

exit_code .dump cr cr
exit_code 0 "Wrong exit code" ASSERT_EQUAL_INTS

// parse state (skip nft general contents)
state <s
3 u@+ swap drop 8 u@+ swap drop 256 u@+ swap drop 64 u@+ swap drop swap drop
ref@+ drop ref@+ drop ref@+ drop ref@+ <s =: stored_signature_params =: stored_slice
stored_slice s>

// bytes
stored_signature_params 8 u@+ =: stored_signature_params =: stored_sign_max_number
stored_signature_params 8 u@+ =: stored_signature_params =: stored_sign_number
stored_signature_params 4 u@+ =: stored_signature_params =: stored_sign_deploy_fee_len
stored_signature_params stored_sign_deploy_fee_len 8 * u@+ =: stored_signature_params =: stored_sign_deploy_fee
stored_signature_params 4 u@+ =: stored_signature_params =: stored_sign_commit_fee_len
stored_signature_params stored_sign_commit_fee_len 8 * u@+ =: stored_signature_params =: stored_sign_commit_fee
stored_signature_params 4 u@+ =: stored_signature_params =: stored_min_stake_len
stored_signature_params stored_min_stake_len 8 * u@+ =: stored_signature_params =: stored_min_stake
stored_signature_params 3 u@+ =: stored_signature_params =: stored_provider_flags
stored_signature_params 8 u@+ =: stored_signature_params =: stored_provider_wc
stored_signature_params 256 u@+ =: stored_signature_params =: stored_provider_addr
stored_signature_params 1 u@+ =: stored_signature_params =: stored_dict_bits

// refs
stored_signature_params ref@+ =: stored_sign_request_code =: stored_signature_params
stored_signature_params ref@+ =: stored_signatures =: stored_signature_params
stored_signature_params s>

// assert contents

stored_sign_max_number 10 "Wrong stored_sign_max_number" ASSERT_EQUAL_INTS
stored_sign_number 1 "Wrong stored_sign_number" ASSERT_EQUAL_INTS
stored_sign_deploy_fee  500000000 "Wrong stored_sign_deploy_fee" ASSERT_EQUAL_INTS
stored_sign_commit_fee 1500000000 "Wrong stored_sign_commit_fee" ASSERT_EQUAL_INTS
stored_min_stake 9000000000 "Wrong stored_min_stake" ASSERT_EQUAL_INTS

<b b{100} s, stored_provider_wc 8 i, stored_provider_addr 256 u, b> boc>B  // stored provider
<b b{100} s, provider_wc 8 i, provider_addr 256 u, b> boc>B        // new provider
"Wrong bytes" ASSERT_EQUAL_BYTES

stored_dict_bits 1 "Wrong stored_dict_bits" ASSERT_EQUAL_INTS  // no signatures

stored_sign_request_code boc>B
sign_request_code s>c boc>B
"Wrong bytes" ASSERT_EQUAL_BYTES

0 stored_signatures 8 udict@ drop s>c boc>B                // stored_signature
<b b{100} s, request_wc 8 i, request_addr 256 u, b> boc>B  // expected_signature
"Wrong bytes" ASSERT_EQUAL_BYTES


// ------------------------ Assert GET method ----------------------

get_signatures_data
code
state
c7 
runvmctx 

=: state
=: exit_code
=: out_signatures
=: out_sign_provider_address
=: out_min_stake
=: out_sign_commit_fee
=: out_sign_deploy_fee
=: out_sign_number
=: out_sign_max_number

out_min_stake 9000000000 "out_min_stake len must be 9000000000" ASSERT_EQUAL_INTS
out_sign_deploy_fee  500000000 "Wrong stored_sign_deploy_fee" ASSERT_EQUAL_INTS
out_sign_commit_fee 1500000000 "Wrong stored_sign_commit_fee" ASSERT_EQUAL_INTS
out_sign_number 1 "out_sign_number len must be 1" ASSERT_EQUAL_INTS
out_sign_max_number 10 "Wrong stored_sign_max_number" ASSERT_EQUAL_INTS
out_signatures count 1 "Signatures are non empty" ASSERT_EQUAL_INTS

out_signatures 1 untuple s>c boc>B                         // out_signature
<b b{100} s, request_wc 8 i, request_addr 256 u, b> boc>B  // expected_signature
"Wrong bytes" ASSERT_EQUAL_BYTES

out_sign_provider_address s>c boc>B                       // out_provider
<b b{100} s, provider_wc 8 i, provider_addr 256 u, b> boc>B  // expected_provider 
"Wrong bytes" ASSERT_EQUAL_BYTES      

exit_code 0 "Wrong exit code" ASSERT_EQUAL_INTS

exit_code ."Exit code " exit_code .dump cr
